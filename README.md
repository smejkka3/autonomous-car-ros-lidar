# Group One - Autonomous Racing Car

This is the README of the repository of our autonomous racing car project. Below you will find a short overview of our project as well as the steps necessary to deploy and run our code in the simulation as well as on the robot.

## Structure

In addition to the given code we developed the following modules:

### Track Detection

The track detection node reads the /map topic generated by the karto-slam node and detects traffic cones on it which are the used to compute the racing track boundaries.
This module makes the following assumptions which must be met in order for it to work:

* Adjacent cones belonging to one side of the track must be closer than maxConeDistance to each other. This can be defined in the launch file of the track detection.
* The track width must always be larget than the maxConeDistance.
* The robot must start inside of the track.
* The track must be empty during the exploration run.

The generated track boundaries are then published on a new map under the topic /map_obstacles

### Racing Control

The racing control unit reads the exploration target from the track detection and feeds it into the global planner as a goal. The /cmd_vel messages generated by the local planner are intercepted and modified based on the current mode (Exploration or Racing).

The racing control can be configured to respect stop messages (linear velocity = 0) by the local planner or to overwrite them. The option in the racing control launch file is called "breakWhenZero".

### Real Car and Simulation

Since we wanted to tune the parameters for several components differently for the simulation and the real car we added two versions of most launch or configuration files which are called *_sim or *_real. Some launch files also contain two sections, one for each scenario.

## Installation Guide

First, clone this git repository, then also get submodules

`git submodule update --init --recursive`

And install the required dependencies via rosdep

`rosdep install --from-paths src --ignore-src -r -y`

Additionally you may need the following ros packages which need to be installed manually:

- Ackermann (`sudo apt install ros-<version>-ackermann*`)
- gstreamer-1.0
- teleop_twist_joy (`sudo apt install ros-<version>-teleop-twist-joy`)
- teleop_twist_keyboard (`sudo apt install ros-<version>-teleop-twist-keyboard`)
- geographic-msgs (`sudo apt install ros-<version>-geographic-msgs`)
- serialConfig (`sudo apt install ros-<version>-serial*`) Only needed on the robot.
- realsense2-camera (`sudo apt install ros-<version>-realsense2-camera`) Only needed on the robot.

## Build

Build using 
```bash
catkin_make
```

## Run

### Simulation
In order to run the simulation, firstly the devel/source.bash has to be sourced.

`source devel/setup.bash`

#### Using tmux

There are already predefined scripts to start all required topics at once using tmux. 
For starting the simulation from scratch run:

`./tmux.sh`

This will start RViz and also the morse enviroment. For more details look into the tmux.sh script where the used ros launch files can be found.

The approripate script has to be made exacutable:

`chmod +x ./tmux.sh`

These commands will start all necessary nodes like pose-follower, karto-slam, the track detection and the odometry system.

To start the autonomous behaviour of the car the racing-control node has to be started via:

`roslaunch racing_control racing_control.launch is_simulation:=true`

#### Manually step-by-step

```
morse import -f morse/fourwd
morse run fourwd
roslaunch pose_follower navigation_stack_fourwd.launch is_simulation:=true
roslaunch odometry_agent odometry_agent.launch is_simulation:=true
# wait until everything is started.
roslaunch racing_control racing_control.launch is_simulation:=true
```

## Real Car
After building everything on the real car make sure to source the correct file:

`source devel/setup.bash`

The complete stack which is started in the simulation via "./tmux.sh" can be started using

`roslaunch bear_car_launch complete_no_rviz.launch `

After this command you only need to start the racing control via

`roslaunch racing_control racing_control.launch is_simulation:=false` 

in order to start the autonomous exploration/racing of the car.

## Visualization
To understand what is going on it is advisable to visualize everything with rviz. Especially the track detection generates a lot of visual information which can be found in rviz when looking at the published topics.

Alternatively you may use our rviz-configuration which can be found in src/pose_follower/cfg.

To use rviz while ros is running on the real car you can use a provided script to make your local ros aware of the ros core running on the car via:

`source scripts/remoteClientNetwork.sh jetson2`

Afterwards rviz can be started normally via 

`rviz`.
# autonomous-car-ros-lidar
